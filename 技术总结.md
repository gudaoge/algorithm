# java基础
## java内存模型
- 工作内存和主内存
    > 主内存是线程共享的区域，工作内存是线程私有的区域
    > 线程不能直接操作主内存，必须将数据从主内存拷贝到工作内存，在工作内存修改后再同步到主内存
- 原子性(工作内存与主内存之间的交互)
    > lock与unlock: 对主内存的锁定和解锁
    > read和load: 将主内存变量传输给工作内存，将传输的变量值放到工作内存的副本中
    > use和assign: 将工作内存变量传递给执行引擎，将执行引擎的结果赋值给工作内存
    > store和write: 将工作内存的变量值传输给主内存，将传输的变量值放入主内存的变量
- 可见性
    > volatile实现多线程中的可见性，通过加入内存屏障，防止指令重排序 
- 有序性
    > happens-before原则保证前一个操作的结果对后一个操作可见
    > 单线程次序
    > 传递性
    > volatile         
    > 锁
    > 线程开始
    > 线程中断
    > 线程终结
    > 对象终结
     
## synchronized
> 锁实现基于对象的mark word，标记着对象的锁状态
> 锁的4种状态
 - 无锁
 - 偏向锁: 依赖对象的mark word，锁指向threadId，cas设置
 - 轻量级锁: 依赖对象的mark word，锁指向锁记录，cas设置
 - 重量级锁: 依赖对象的mark word，锁指向monitor记录，而monitor又是基于操作系统mutex lock，需要切换用户态和内核态
> 锁状态可升级不可降级
> 锁优化
 - 锁粗化
 - 锁消除
 - 自旋
 - 适应性自旋
 
## lock

## aqs

## volatile
volatile主要有两个功能，一个是可见性，一个是防止指令重排序
- 可见性
> 主要是依靠lock前缀实现，当volatile变量被修改时，会强制写回到主存，并使其他cpu的缓存行无效
> lock前缀的实现依靠cpu本身来实现，主要由总线锁和缓存行锁实现
> 总线锁会禁止其他cpu访问主存，开销比较大
> 缓存行锁依靠缓存一致性协议来实现，也就是MESI等协议
> 由于缓存行可能会保存若干个变量，修改其中一个会使整行失效，也即是伪共享问题，针对这个问题，可以采用缓存填充的方式，使变量不在同一缓存行
- 防止指令重排序
> cpu层面依靠内存屏障实现

## MESI协议

## cas

## 线程池
核心就是依靠工作线程，任务队列
对于工作线程，分为核心线程和非核心线程
任务优先分给核心线程，核心线程占满后放入任务队列
队列满后分给非核心线程，当非核心线程也占满之后采用拒绝策略

因此线程池关键参数为：
- 核心线程数
- 最大线程数
- 任务队列
- 拒绝策略
- 非核心线程空闲时间
- 线程工厂

## hashMap
主要就是数组加链表，并发版的采用cas和synchronized锁链表头

## gc
### 对象存活判断
- 引用计数法
    > 无法解决相互引用问题
- 可达性分析
    > 通过遍历gcRoot，当对象无法由gcRoot达到时，可以被回收

### gc算法
- 复制算法
    > 快，无碎片
    > 需要消耗额外空间
- 标记-清除算法    
    > 实现简单，不消耗额外空间
    > 会产生碎片，分配空间慢
    > 与fork不兼容
- 标记-整理算法
    > 无碎片
    > 整理耗费时间
### 垃圾回收器
- serial
    > 单线程，复制
- parNew
    > 多线程，复制
- parallel
    > 高吞吐，复制
- serialOld
    > 单线程，标记-整理
- parallelOld
    > 多线程，标记-整理
- cms
    > 单次最短时间，标记-清除
- g1
    
## 内存分区
java内存主要分为这么几块
- 堆 : 主要存储对象
    > 新生代
    > 老年代
- 栈 : 栈保存栈帧，栈帧保存局部变量表，方法出口，每次方法的调用和返回就是入栈和出栈
    > 虚拟机栈
    > 本地方法栈
- 方法区: 存储类信息，常量，方法，即时编译后的代码缓存等
    > 不同的虚拟机实现有所区别，比如PermGen，metaSpace
- 程序计数器

# spring
## bean的初始化
## 循环依赖的解决
## aop
## spring事务
> 基于aop，拦截所有需要事务的方法
> 事务管理的抽象，将数据库连接绑定到当前线程

# rpc
## dubbo
### 服务发现和注册

### 负载均衡和容错

### rpc请求的过程

# mq
## rocketmq
### 角色
- nameServer
- producer
- consumer
- broker
### 存储架构
- commitLog
> 所有topic共享写入到同一个commitLog中
- consumeQueue
> 相当于按queueId纬度的commitLog索引，基于索引可以在commitLog中找到消息
- indexFile
> 相当于一个全局的索引，提供根据key或者时间查询的功能

### 高性能
- pageCache

- 内存映射

### 角色间通信
> broker注册到nameServer，并定时上报topic信息
> producer定时从nameServer拉取topic信息并缓存，选取消息队列发送给broker，broker存盘
> consumer定时从nameServer拉取topic信息并缓存，根据负载均衡选择其中几个消息队列进行消费
### 通信框架
> 采用netty进行网络通信

### consumer的消费模式
- pull
    > 消费者自己决定什么时候拉取
- push
    > 长轮询，30秒内有消息会返回消息，否则阻塞30秒后返回超时
### consumer的负载均衡
> 心跳包，向所有broker发送心跳，汇集元数据，为负载均衡作准备
> 每20秒启动负载均衡，向broker拉取topic下的所有consumerId，将消费队列分配给consumerId   
> 锁定队列，锁定成功后开始消费当前队列
> 每个队列只能由一个消费者消费，每个消费者可以消费多个队列

### 事务消息
> 采用半消息实现，先发一条消息，然后执行本地事务，根据事务结果对消息进行commit和rollback
> broker定时对没有commit或rollback的消息回查，producer根据本地事务状态进行commit或者rollback
> 事务消息会发送到一个特殊的topic中，然后broker自身定时消费回查
### 顺序消息
> producer根据特定策略将有序的消息发送到同一个队列
> consumer单线程的消费队列中的消息
### 延迟消息
> 通过写入到特定的topic中，然后broker定时消费topic写入到真实的topic中
## 消费重试
> 消费失败的消息写入到重试队列中
> 因为重试需要延迟，因此会写入到延迟消息，在定时写到重试队列

# database
## mysql
### innodb
### b+tree
### 事务
### binlog

# 缓存
## redis
### 数据结构

### 回收策略

### 持久化
- RDB
- AOF以及AOF重写

### 高性能原因
- 纯内存
- epoll IO多路复用
- 单线程
- 高效的数据结构
- reactor模型，事件驱动

### 主从同步
- 全量同步
    > 一般发生在slave启动时，也可以随时发生
- 增量同步
    > master每进行一次写命令，都会发送给slave
    
### 哨兵
> 用于主从切换，高可用解决方案
> 监控服务器状态，下线失效的服务器，选出新的master
### 集群

# 注册中心
## zk
### 数据结构
> zk采用树形结构，树形节点分为4种  
- 持久节点
- 顺序持久节点
- 临时节点
- 顺序临时节点 

> 临时节点与session有关，根据session的心跳来续租，当session断开时，节点删除
> 顺序节点会自动以最近的已存在节点序号+1创建并返回节点名

### 节点的监听
> 当节点发生变更时，监听这个节点的watcher都会收到事件
    
### 写请求
> 集群下所有的写请求都会转发到leader，由leader广播请求，当leader接收到半数follower的ack之后发起commit

### zk集群的选举

### zk的CAP
> 选举过程中无法对外提供服务，所以牺牲了可用性，因此是CP

### 使用zk作为分布式锁
> 创建临时顺序节点，并判断自己创建的节点是不是最小的，是的话就获取到了锁，不是的话监听比他小的节点

### 使用zk辅助选举
> 创建临时顺序节点，以最小的节点作为master

## eureka

# 配置中心
## apollo
> 阿波罗采用分布式集群部署，包含若干种角色，每个角色无状态，角色如下
- metaServer: 服务发现的封装，提供获取服务列表的功能
- configService: 配置拉取和推送，面向客户端
- adminService: 配置的变更与发布，面向管理后台
### 配置修改发布
> 通过adminService对外暴露服务，发布成功后会通知configService使client拉去最新配置
### 配置的读取和推送
> 通过长轮询拉去最新配置，若配置无变更，轮询请求会挂起直到超时返回，否则会返回变更的namespace，使客户端重新拉取最新配置
### 热修改
> 后台配置发布成功后通过mq通知configService，configService会将立刻将长轮询的结果设置并返回修改的namespace

# 网络通信
## netty

# 分库分表
## sharding-jdbc

# 分布式事务
- 2pc
- 3pc
- tcc
- 事务消息